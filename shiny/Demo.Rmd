---
title: "Demo_TFplot_shiny"
author: "Bruce Zheng"
date: "3/30/2021"

params:
  geojson: "/Users/app/Desktop/Remote Sensing Presentation/vector_data/glaciers.geojson"
  basins: "/Users/app/Desktop/Remote Sensing Presentation/Index/train_list-small (1).csv"
  n_patches: 75
  preds_dir: "/Users/app/Desktop/Remote Sensing Presentation/model/preds"
output: html_document
---
```{r}
library(tmap)
library(shiny)
library(tmaptools)
library("stringr")
library("tidyr")
library(DT)# for static and interactive maps
library(leaflet) # for interactive maps
library(ggplot2) # tidyverse data visualization package
library(rgdal)
library("purrr")
library("raster")
library("readr")
library("sf")
library("reticulate")
library("RStoolbox")
library("abind")
library("dplyr")
library("gdalUtils")
library("ggplot2")
library(plotly)
library(cowplot)
library(gridExtra)
library(gridGraphics)
library(grid)
library(leafletplugins)
library(leaflet.extras)


np <- import("numpy")
source("data.R")
source("metrics.R")




use_condaenv("notebook")

theme_set(theme_minimal())


```

```{r}
y_path <- file.path(params$geojson)
basins <- read_csv(params$basins)
basins
```

```{r}
#load the data
y_sub <- read_sf(y_path) %>%
  filter(Sub_basin %in% basins$Sub_basin)

centers <- y_sub %>%
  st_sample(params$n_patches, type = "random", by_polygon = FALSE) %>%
  st_coordinates()

colnames(centers) <- c("Longitude", "Latitude")
center_df<-data.frame(centers)
coordinates(center_df)<-~Longitude+Latitude
center_df$id<-c(1:nrow(centers))
center_df$Long<-round(centers[1:nrow(centers),1],2)
center_df$Lat<-round(centers[1:nrow(centers),2],2)

paths<-prediction_paths(params$preds)
```

```{r}
Icon <- makeIcon(
  iconUrl = "/Users/app/Desktop/Remote Sensing Presentation/Code/Shiny app code/9521617427822_.pic.jpg",
  iconWidth = 10, iconHeight = 20,
  iconAnchorX = 5, iconAnchorY = 20,)

#greenLeafIcon <- makeIcon(
  #iconWidth = 38, iconHeight = 95,
  #iconAnchorX = 22, iconAnchorY = 94,)

#,clusterOptions = markerClusterOptions()

```

```{r}
num<-c(unique(paths[paths$split=="test",]$ix))
length(num)
num=1
x_test<-load_npy(paths[paths$split=="test"&paths$ix==2&paths$type=="x",]$path)
y_test<-load_npy(paths[paths$split=="test"&paths$ix==2&paths$type=="y",]$path)
ggRGB(x_test)
ggRGB(y_test)
x_test

mean(coordinates(x_test)[,1])
mean(coordinates(x_test)[,2])
y <- read_sf("/Users/app/Desktop/Remote Sensing Presentation/preprocessed/train/geo-2.geojson")
print(st_centroid(y))
tm_shape(st_as_sf(as.data.frame(y))) + tm_polygons("Glaciers")
```

```{r}
split_id<-c(unique(paths[paths$split=="test",]$ix))
IOU<-c();prob<-0.5
for (num in split_id){
  y<-np$load(paths[paths$split=="test"&paths$ix==num&paths$type=="y",]$path)
  
  y_hat<-np$load(paths[paths$split=="test"&paths$ix==num&paths$type=="y_hat",]$path)
  y_hat[y_hat>=prob]=1;y_hat[y_hat<prob]=0
  
  iou<-array(0, dim=c(512,512))
  for (i in c(1:512)){
    for (j in c(1:512)){
      if(all(y[,i,j]==y_hat[,i,j])){
        iou[i,j]<-1
      }
      else iou[i,j]<-0
    }
  }
  
  IOU<-c(IOU,mean(iou))
}

IOU_df<-data.frame(IOU=round(IOU,3),index=split_id)
IOU_sort<-IOU_df %>% arrange(desc(IOU))
#iou <- IOU_sort %>%
  #ggplot( aes(index, IOU)) +
  #geom_point() +
  #theme_bw()
iou<-ggplot(IOU_df, aes(x = reorder(index, IOU), y = IOU)) +
         geom_point(size = 0.5)+theme(axis.text.x = element_blank(),axis.title.y = element_text(size =8),axis.title.x = element_text(size =8))

ggplotly(iou)
#citation("plotly")

```

```{r}
# 1-tp
#test the time
#transparent parameter, lay mask on the image
#add title headline

#histogram and brush ,  update the markers#link visualization , interactive linking, coordinates

```

```{r}

ui<-fluidPage(h2("Interactive Figure"),
 fluidRow(column(5, leafletOutput('Map')),column(5,plotlyOutput("curve")),column(2,  selectInput("c", "Channel", c(1,2,3))),column(2,  sliderInput("p", "Threshold Probability", value = 0.5, min = 0, max = 1))),
 h2("Prediction Results Comparing with raw data"),
  fluidRow(column(12, plotOutput('grid',height = "300px"))))

```

```{r}
server<-shinyServer(function(input, output, session){
    output$Map <- renderLeaflet({
      leafmap_shp<-tmap_leaflet(tm_shape(st_as_sf(as.data.frame(y_sub))) + tm_polygons("Glaciers") + tm_facets(nrow = 1, sync = TRUE))%>% addMarkers(center_df$Long,center_df$Lat,popup=paste("ID:",center_df$id,"<br>","Longitude:", center_df$Long, "<br>","Latitude:", center_df$Lat), label =center_df$id,group = 'id', layerId = center_df$id,icon = Icon) %>% addSearchMarker('id', position = 'topleft', propertyName = center_df$id) 
      leafmap_shp})
  
    click<-reactive(input$Map_marker_click);id<-reactive(as.numeric(click()$id))
    result<-reactive(paths[paths$ix==id()& paths$split=="train",])
    y <- reactive({np$load(result()[result()$type=="y",]$path)})
    y_hat<-reactive(np$load(result()[result()$type=="y_hat",]$path))
    
    output$curve<-renderPlotly(ggplotly(iou))


    
    output$grid<-renderPlot({
        probability<-as.numeric(input$p)
        channel<-as.numeric(input$c)
        
        x_raster<-load_npy(result()[result()$type=="x",]$path)
        y_raster<-load_npy(result()[result()$type=="y",]$path)
        
        y_m<-y();y_hat_m<-y_hat()
        tp<-y_m[channel,,]==1&y_hat_m[channel,,]>=probability
        fn<-y_m[channel,,]==1&y_hat_m[channel,,]<probability
        fp<-y_m[channel,,]==0&y_hat_m[channel,,]>=probability
        tn<-y_m[channel,,]==0&y_hat_m[channel,,]<probability
        result_new<-1*tp+2*fn+3*fp+4*tn
        result_r <- t(apply(result_new, 2, rev))

        result_vec<-as.vector(t(result_r))#替换为TP，TN，PF，PN等，然后
        result_vec<-replace(result_vec,result_vec==1, "TP")
        result_vec<-replace(result_vec,result_vec==2, "FN")
        result_vec<-replace(result_vec,result_vec==3, "FP")
        result_vec<-replace(result_vec,result_vec==4, "TN")
    
        result_df<-data.frame(x=rep(c(1:512),each=512),y=rep(1:512,512),class=result_vec)
        result_df$class<-as.factor(result_df$class)
        cols <- c("TP" = "green", "FN" = "red", "FP" = "black", "TN" = "white")
        p1<-ggplot(result_df, aes(x,y)) +geom_raster(aes(fill = class))+scale_fill_manual(values=cols)+theme(
          axis.text = element_blank(),axis.ticks = element_blank(),
          axis.title = element_blank(),panel.background = element_blank(),
          plot.margin = unit(c(0, 0, 0, 0), "cm")) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) + coord_fixed() 
    
      legend <- get_legend(p1)

      p2<-plot_rgb(y_raster)
      p3<-plot_rgb(x_raster)
      p <- list(p2,p3,p1+theme(legend.position = "none"))
      grid.arrange(p3,p2,p1+theme(legend.position = "none"),legend,layout_matrix=rbind(c(1,1,1,1,2,2,2,2,3,3,3,3,4)))})
})

shinyApp(ui, server)


```

```{r}


```


